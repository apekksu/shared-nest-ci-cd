name: Shared CI/CD for NestJS

on:
  workflow_call:
    inputs:
      s3-bucket-name: { required: true, type: string }
      application-name: { required: true, type: string }
      application-port: { required: true, type: number }
      aws-region: { required: false, type: string, default: 'eu-central-1' }
      secret-name: { required: true, type: string }
      ec2-app-tag: { required: true, type: string }
    secrets:
      aws-access-key-id: { required: true }
      aws-secret-access-key: { required: true }

jobs:
  upload-shared-files:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Shared Repository
        uses: actions/checkout@v4
        with:
          repository: apekksu/shared-nest-ci-cd
          ref: main

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.aws-access-key-id }}
          aws-secret-access-key: ${{ secrets.aws-secret-access-key }}
          aws-region: ${{ inputs.aws-region }}

      - name: Upload deploy script to S3
        run: |
          aws s3 cp ./scripts/deploy-nest.sh s3://${{ inputs.s3-bucket-name }}/scripts/deploy-nest.sh

  build-and-deploy:
    needs: upload-shared-files
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Application Repository
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.aws-access-key-id }}
          aws-secret-access-key: ${{ secrets.aws-secret-access-key }}
          aws-region: ${{ inputs.aws-region }}

      - name: Setup Node.js environment
        uses: actions/setup-node@v4
        with:
          node-version: '22.11.0'

      - name: Install dependencies
        run: npm ci

      - name: Build application
        run: npm run build

      - name: Inspect artifact layout (debug)
        run: |
          echo "== zip contents (top 200 lines) =="
          unzip -l "${{ inputs.application-name }}.zip" | sed -n '1,200p'
          echo
          echo "== does it contain dist/main.js or dist/src/main.js? =="
          unzip -l "${{ inputs.application-name }}.zip" \
            | awk '{print $NF}' \
            | grep -E '^dist/(src/)?main\.js$' \
            || echo "No entry file matched."

      - name: Package application
        run: |
          zip -r ${{ inputs.application-name }}.zip \
            dist package.json package-lock.json node_modules

      - name: Upload package to S3
        run: |
          aws s3 cp ${{ inputs.application-name }}.zip s3://${{ inputs.s3-bucket-name }}/${{ inputs.application-name }}/

      - name: Retrieve Specific EC2 Instance Information
        shell: bash
        run: |
          set -euo pipefail
          export AWS_PAGER=""

          mapfile -t IDS < <(aws --no-cli-pager ec2 describe-instances \
            --filters "Name=tag:App,Values=${{ inputs.ec2-app-tag }}" "Name=instance-state-name,Values=running" \
            --query 'Reservations[].Instances[].InstanceId' \
            --output text | tr '\t' '\n' | sed '/^$/d')

          COUNT=${#IDS[@]}
          if [[ $COUNT -eq 0 ]]; then
            echo "No running instances found for App=${{ inputs.ec2-app-tag }}"; exit 1
          elif [[ $COUNT -gt 1 ]]; then
            echo "Expected exactly 1 running instance for App=${{ inputs.ec2-app-tag }}, found $COUNT:"
            aws --no-cli-pager ec2 describe-instances \
              --filters "Name=tag:App,Values=${{ inputs.ec2-app-tag }}" "Name=instance-state-name,Values=running" \
              --query 'Reservations[].Instances[].{Id:InstanceId,Name:Tags[?Key==`Name`]|[0].Value,IP:PublicIpAddress,Launch:LaunchTime}' \
              --output table
            exit 1
          fi

          EC2_INSTANCE_ID="${IDS[0]}"
          EC2_PUBLIC_IP=$(aws --no-cli-pager ec2 describe-instances --instance-ids "$EC2_INSTANCE_ID" \
            --query 'Reservations[0].Instances[0].PublicIpAddress' --output text)

          echo "EC2 Instance ID: $EC2_INSTANCE_ID"
          echo "EC2 Public IP: ${EC2_PUBLIC_IP:-}"

          {
            printf 'EC2_INSTANCE_ID=%s\n' "$EC2_INSTANCE_ID"
            printf 'EC2_PUBLIC_IP=%s\n' "${EC2_PUBLIC_IP:-}"
          } >> "$GITHUB_ENV"

      - name: Preflight — verify deploy script, secret, and artifact exist
        shell: bash
        run: |
          set -euo pipefail
          export AWS_PAGER=""
          echo "Checking S3 deploy script…"
          aws --no-cli-pager s3 ls "s3://${{ inputs.s3-bucket-name }}/scripts/deploy-nest.sh" >/dev/null
          echo "Checking Secrets Manager secret…"
          aws --no-cli-pager secretsmanager describe-secret --secret-id "${{ inputs.secret-name }}" >/dev/null
          echo "Checking S3 artifact…"
          aws --no-cli-pager s3 ls "s3://${{ inputs.s3-bucket-name }}/${{ inputs.application-name }}/${{ inputs.application-name }}.zip" >/dev/null

      - name: Deploy application using SSM
        shell: bash
        run: |
          set -euo pipefail
          export AWS_PAGER=""

          CMDS_JSON=$(
            printf '%s\n' \
              "bash -lc 'echo ==== preflight diag ====; id; whoami; uname -a; aws --version || true; node -v || true; npm -v || true; which pm2 || true; pm2 -v || true'" \
              "aws s3 cp s3://${{ inputs.s3-bucket-name }}/scripts/deploy-nest.sh /tmp/deploy-nest.sh" \
              "chmod +x /tmp/deploy-nest.sh" \
              "sed -i -E \"s|^exec > .*tee .*|# disabled by CI: exec tee|\" /tmp/deploy-nest.sh || true" \
              "bash -lc 'command -v pm2 >/dev/null 2>&1 || npm i -g pm2'" \
              "bash -lc '/tmp/deploy-nest.sh \"${{ inputs.application-name }}\" \"${{ inputs.application-port }}\" \"${{ inputs.s3-bucket-name }}\" \"${{ inputs.secret-name }}\"'" \
            | jq -R . | jq -s '{commands: .}'
          )

          COMMAND_ID=$(aws --no-cli-pager ssm send-command \
            --instance-ids "${{ env.EC2_INSTANCE_ID }}" \
            --document-name "AWS-RunShellScript" \
            --parameters "$CMDS_JSON" \
            --cloud-watch-output-config CloudWatchOutputEnabled=true,CloudWatchLogGroupName="/aws/ssm/RunCommand" \
            --timeout-seconds 1800 \
            --region ${{ inputs.aws-region }} \
            --comment "deploy ${{ inputs.application-name }} run $GITHUB_RUN_ID" \
            --query "Command.CommandId" \
            --output text)

          echo "COMMAND_ID=$COMMAND_ID" >> "$GITHUB_ENV"
          echo "Sent command: $COMMAND_ID"

      - name: Wait and dump SSM output
        shell: bash
        run: |
          set -euo pipefail
          export AWS_PAGER=""

          for i in {1..60}; do
            OUT=$(aws --no-cli-pager ssm get-command-invocation \
              --command-id "${{ env.COMMAND_ID }}" \
              --instance-id "${{ env.EC2_INSTANCE_ID }}" \
              --region ${{ inputs.aws-region }} \
              --output json)
            STATUS=$(jq -r '.Status' <<<"$OUT")
            echo "SSM status: $STATUS"
            [[ "$STATUS" == "InProgress" || "$STATUS" == "Pending" || "$STATUS" == "Delayed" ]] && sleep 5 && continue

            echo "----- StandardOutputContent -----"
            jq -r '.StandardOutputContent' <<<"$OUT" || true
            echo "----- StandardErrorContent ------"
            jq -r '.StandardErrorContent' <<<"$OUT" || true

            echo "----- Plugin Output (details) -----"
            aws --no-cli-pager ssm list-command-invocations \
              --command-id "${{ env.COMMAND_ID }}" \
              --details \
              --region ${{ inputs.aws-region }} \
              --output json \
              | jq -r '.CommandInvocations[].CommandPlugins[] | "PLUGIN: \(.Name)  STATUS: \(.Status)\n" + (.Output // "")'

            [[ "$STATUS" == "Success" ]] && exit 0 || exit 1
          done
          echo "Timed out waiting for SSM command"; exit 1

      - name: Fetch remote deploy logs
        if: always()
        continue-on-error: true
        shell: bash
        run: |
          set -euo pipefail
          export AWS_PAGER=""

          cat > log_params.json <<JSON
          {
            "commands": [
              "echo ===== /home/ubuntu/deploy_script.log (tail -300) =====",
              "sudo tail -n 300 /home/ubuntu/deploy_script.log || true",
              "echo",
              "echo ===== pm2 list =====",
              "sudo -u ubuntu pm2 list || true",
              "echo",
              "echo ===== /var/log/cloud-init-output.log (tail -100) =====",
              "sudo tail -n 100 /var/log/cloud-init-output.log || true"
            ]
          }
          JSON

          LOG_CMD_ID=$(aws --no-cli-pager ssm send-command \
            --instance-ids "${{ env.EC2_INSTANCE_ID }}" \
            --document-name "AWS-RunShellScript" \
            --parameters file://log_params.json \
            --region ${{ inputs.aws-region }} \
            --query "Command.CommandId" --output text)

          aws --no-cli-pager ssm wait command-executed \
            --command-id "$LOG_CMD_ID" \
            --instance-id "${{ env.EC2_INSTANCE_ID }}" \
            --region ${{ inputs.aws-region }}

          aws --no-cli-pager ssm get-command-invocation \
            --command-id "$LOG_CMD_ID" \
            --instance-id "${{ env.EC2_INSTANCE_ID }}" \
            --region ${{ inputs.aws-region }} \
            --output text || true

      - name: Verify Deployment
        run: |
          echo "Deployment completed."
          echo "Application is accessible at http://${{ env.EC2_PUBLIC_IP }}:${{ inputs.application-port }}/"
