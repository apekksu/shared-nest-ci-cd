name: Shared CI/CD for NestJS

on:
  workflow_call:
    inputs:
      s3-bucket-name: { required: true, type: string }
      application-name: { required: true, type: string }
      application-port: { required: true, type: number }
      aws-region: { required: false, type: string, default: 'eu-central-1' }
      secret-name: { required: true, type: string }
      ec2-app-tag: { required: true, type: string }
    secrets:
      aws-access-key-id: { required: true }
      aws-secret-access-key: { required: true }

jobs:
  upload-shared-files:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Shared Repository
        uses: actions/checkout@v4
        with:
          repository: apekksu/shared-nest-ci-cd
          ref: main

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.aws-access-key-id }}
          aws-secret-access-key: ${{ secrets.aws-secret-access-key }}
          aws-region: ${{ inputs.aws-region }}

      - name: Upload deploy script to S3
        run: |
          aws s3 cp ./scripts/deploy-nest.sh s3://${{ inputs.s3-bucket-name }}/scripts/deploy-nest.sh

  build-and-deploy:
    needs: upload-shared-files
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Application Repository
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.aws-access-key-id }}
          aws-secret-access-key: ${{ secrets.aws-secret-access-key }}
          aws-region: ${{ inputs.aws-region }}

      - name: Setup Node.js environment
        uses: actions/setup-node@v4
        with:
          node-version: '22.11.0'

      - name: Install dependencies
        run: npm ci

      - name: Build application
        run: npm run build

      - name: Prune to production deps
        run: npm prune --omit=dev

      - name: Package application
        run: |
          zip -r ${{ inputs.application-name }}.zip \
            dist package.json package-lock.json node_modules

      - name: Inspect artifact layout (debug)
        run: |
          echo "== zip contents (top 200 lines) =="
          unzip -l "${{ inputs.application-name }}.zip" | sed -n '1,200p'
          echo
          echo "== does it contain dist/main.js or dist/src/main.js? =="
          unzip -l "${{ inputs.application-name }}.zip" \
            | awk '{print $NF}' \
            | grep -E '^dist/(src/)?main\.js$' \
            || echo "No entry file matched."

      - name: Upload package to S3
        run: |
          aws s3 cp ${{ inputs.application-name }}.zip s3://${{ inputs.s3-bucket-name }}/${{ inputs.application-name }}/

      - name: Retrieve Specific EC2 Instance Information
        shell: bash
        run: |
          set -euo pipefail
          export AWS_PAGER=""

          mapfile -t IDS < <(aws --no-cli-pager ec2 describe-instances \
            --filters "Name=tag:App,Values=${{ inputs.ec2-app-tag }}" "Name=instance-state-name,Values=running" \
            --query 'Reservations[].Instances[].InstanceId' \
            --output text | tr '\t' '\n' | sed '/^$/d')

          COUNT=${#IDS[@]}
          if [[ $COUNT -eq 0 ]]; then
            echo "No running instances found for App=${{ inputs.ec2-app-tag }}"; exit 1
          elif [[ $COUNT -gt 1 ]]; then
            echo "Expected exactly 1 running instance for App=${{ inputs.ec2-app-tag }}, found $COUNT:"
            aws --no-cli-pager ec2 describe-instances \
              --filters "Name=tag:App,Values=${{ inputs.ec2-app-tag }}" "Name=instance-state-name,Values=running" \
              --query 'Reservations[].Instances[].{Id:InstanceId,Name:Tags[?Key==`Name`]|[0].Value,IP:PublicIpAddress,Launch:LaunchTime}' \
              --output table
            exit 1
          fi

          EC2_INSTANCE_ID="${IDS[0]}"
          EC2_PUBLIC_IP=$(aws --no-cli-pager ec2 describe-instances --instance-ids "$EC2_INSTANCE_ID" \
            --query 'Reservations[0].Instances[0].PublicIpAddress' --output text)

          echo "EC2 Instance ID: $EC2_INSTANCE_ID"
          echo "EC2 Public IP: ${EC2_PUBLIC_IP:-}"

          {
            printf 'EC2_INSTANCE_ID=%s\n' "$EC2_INSTANCE_ID"
            printf 'EC2_PUBLIC_IP=%s\n' "${EC2_PUBLIC_IP:-}"
          } >> "$GITHUB_ENV"

      - name: Preflight — verify deploy script, secret, and artifact exist
        shell: bash
        run: |
          set -euo pipefail
          export AWS_PAGER=""
          echo "Checking S3 deploy script…"
          aws --no-cli-pager s3 ls "s3://${{ inputs.s3-bucket-name }}/scripts/deploy-nest.sh" >/dev/null
          echo "Checking Secrets Manager secret…"
          aws --no-cli-pager secretsmanager describe-secret --secret-id "${{ inputs.secret-name }}" >/dev/null
          echo "Checking S3 artifact…"
          aws --no-cli-pager s3 ls "s3://${{ inputs.s3-bucket-name }}/${{ inputs.application-name }}/${{ inputs.application-name }}.zip" >/dev/null

      - name: Deploy application using SSM
        shell: bash
        run: |
          set -euo pipefail
          export AWS_PAGER=""

          CMDS_JSON=$(
            printf '%s\n' \
              "bash -lc 'echo ==== preflight diag ====; id; whoami; uname -a; aws --version || true; node -v || true; npm -v || true; sudo -u ubuntu bash -lc \"echo ubuntu node: \$(node -v); echo ubuntu npm: \$(npm -v)\" || true; sudo -u ubuntu -H which pm2 || true; sudo -u ubuntu -H pm2 -v || true'" \
              "bash -lc 'command -v unzip >/dev/null 2>&1 || (apt-get update -y && DEBIAN_FRONTEND=noninteractive apt-get install -y unzip)'" \
              "bash -lc 'command -v jq >/dev/null 2>&1 || (apt-get update -y && DEBIAN_FRONTEND=noninteractive apt-get install -y jq)'" \
              "aws s3 cp s3://${{ inputs.s3-bucket-name }}/scripts/deploy-nest.sh /tmp/deploy-nest.sh" \
              "chmod +x /tmp/deploy-nest.sh" \
              "bash -lc 'NO_TEE=1 /tmp/deploy-nest.sh \"${{ inputs.application-name }}\" \"${{ inputs.application-port }}\" \"${{ inputs.s3-bucket-name }}\" \"${{ inputs.secret-name }}\"'" \
            | jq -R . | jq -s '{commands: .}'
          )

          COMMAND_ID=$(aws --no-cli-pager ssm send-command \
            --instance-ids "${{ env.EC2_INSTANCE_ID }}" \
            --document-name "AWS-RunShellScript" \
            --parameters "$CMDS_JSON" \
            --cloud-watch-output-config CloudWatchOutputEnabled=true,CloudWatchLogGroupName="/aws/ssm/RunCommand" \
            --timeout-seconds 1800 \
            --region ${{ inputs.aws-region }} \
            --comment "deploy ${{ inputs.application-name }} run $GITHUB_RUN_ID" \
            --query "Command.CommandId" --output text)

          echo "COMMAND_ID=$COMMAND_ID" >> "$GITHUB_ENV"
          echo "Sent command: $COMMAND_ID"


      - name: Wait and dump SSM output
        shell: bash
        run: |
          set -euo pipefail
          export AWS_PAGER=""

          for i in {1..60}; do
            OUT=$(aws --no-cli-pager ssm get-command-invocation \
              --command-id "${{ env.COMMAND_ID }}" \
              --instance-id "${{ env.EC2_INSTANCE_ID }}" \
              --region ${{ inputs.aws-region }} \
              --output json)
            STATUS=$(jq -r '.Status' <<<"$OUT")
            echo "SSM status: $STATUS"
            [[ "$STATUS" == "InProgress" || "$STATUS" == "Pending" || "$STATUS" == "Delayed" ]] && sleep 5 && continue

            echo "----- StandardOutputContent -----"
            jq -r '.StandardOutputContent' <<<"$OUT" || true
            echo "----- StandardErrorContent ------"
            jq -r '.StandardErrorContent' <<<"$OUT" || true

            echo "----- Plugin Output (details) -----"
            aws --no-cli-pager ssm list-command-invocations \
              --command-id "${{ env.COMMAND_ID }}" \
              --details \
              --region ${{ inputs.aws-region }} \
              --output json \
              | jq -r '.CommandInvocations[].CommandPlugins[] | "PLUGIN: \(.Name)  STATUS: \(.Status)\n" + (.Output // "")'

            [[ "$STATUS" == "Success" ]] && exit 0 || exit 1
          done
          echo "Timed out waiting for SSM command"; exit 1

      - name: Health check (via SSM on instance)
        shell: bash
        run: |
          set -euo pipefail
          CMDS_JSON=$(
            printf '%s\n' \
              "bash -lc 'set -e
                name=\"${{ inputs.application-name }}-${{ inputs.application-port }}\"
                port=${{ inputs.application-port }}
                hp=\${HEALTH_PATH:-/health}
                for i in {1..40}; do
                  code=\$(curl -s -o /dev/null -w \"%{http_code}\" http://127.0.0.1:\$port\"\$hp\" || true)
                  echo LOCAL_HTTP \$code

                  lsn_ok=1; ss -H -lntp 2>/dev/null | grep -q \":\$port \" || lsn_ok=0

                  # require either HTTP 2xx/3xx OR an actual listener
                  case \"\$code\" in 2*|3*) exit 0;; esac
                  if [[ \$lsn_ok -eq 1 ]]; then exit 0; fi

                  sleep 3
                done
                echo Local health check failed; exit 1'" \
            | jq -R . | jq -s '{commands: .}'
          )

          CMD_ID=$(aws --no-cli-pager ssm send-command \
            --instance-ids "${{ env.EC2_INSTANCE_ID }}" \
            --document-name "AWS-RunShellScript" \
            --parameters "$CMDS_JSON" \
            --region ${{ inputs.aws-region }} \
            --query "Command.CommandId" --output text)

          for i in {1..60}; do
            OUT=$(aws --no-cli-pager ssm get-command-invocation \
              --command-id "$CMD_ID" --instance-id "${{ env.EC2_INSTANCE_ID }}" \
              --region ${{ inputs.aws-region }} --output json)
            STATUS=$(jq -r '.Status' <<<"$OUT")
            echo "LOCAL SSM health status: $STATUS"
            [[ "$STATUS" == "InProgress" || "$STATUS" == "Pending" || "$STATUS" == "Delayed" ]] && sleep 3 && continue
            jq -r '.StandardOutputContent' <<<"$OUT" || true
            jq -r '.StandardErrorContent' <<<"$OUT" || true
            [[ "$STATUS" == "Success" ]] && exit 0 || exit 1
          done
          echo "Timed out waiting for local health check"; exit 1

      - name: Health check (public IP, best-effort)
        if: always()
        continue-on-error: true
        run: |
          for i in {1..20}; do
            code=$(curl -sS --connect-timeout 3 --max-time 5 -o /dev/null -w '%{http_code}' \
              "http://${{ env.EC2_PUBLIC_IP }}:${{ inputs.application-port }}/health" || true)
            echo "PUBLIC_HTTP $code"
            case "$code" in
              2*|3*|404) exit 0;;  # OK if healthy or just missing route
            esac
            sleep 3
          done
          echo "Public probe saw no 2xx/3xx/404 — likely SG/path mismatch."
        

      - name: Fetch remote deploy logs
        if: always()
        continue-on-error: true
        shell: bash
        run: |
          set -euo pipefail
          export AWS_PAGER=""

          cat > log_params.json <<JSON
          {
            "commands": [
              "echo '===== /home/ubuntu/deploy_script.log (tail -300) ====='",
              "sudo tail -n 300 /home/ubuntu/deploy_script.log || true",
              "echo",
              "echo '===== pm2 list ====='",
              "sudo -u ubuntu pm2 list || true",
              "echo",
              "echo '===== /var/log/cloud-init-output.log (tail -100) ====='",
              "sudo tail -n 100 /var/log/cloud-init-output.log || true",
              "echo '===== listeners (ss) ====='",
              "sudo ss -lntp | sed -n '1,200p' || true",
              "echo",
              "echo '===== pm2 logs (last 200) ====='",
              "sudo -u ubuntu pm2 logs ${{
                inputs.application-name
              }}-${{ inputs.application-port }} --lines 200 --nostream || true"
            ]
          }
          JSON

          LOG_CMD_ID=$(aws --no-cli-pager ssm send-command \
            --instance-ids "${{ env.EC2_INSTANCE_ID }}" \
            --document-name "AWS-RunShellScript" \
            --parameters file://log_params.json \
            --region ${{ inputs.aws-region }} \
            --query "Command.CommandId" --output text)

          aws --no-cli-pager ssm wait command-executed \
            --command-id "$LOG_CMD_ID" \
            --instance-id "${{ env.EC2_INSTANCE_ID }}" \
            --region ${{ inputs.aws-region }} || true

          aws --no-cli-pager ssm get-command-invocation \
            --command-id "$LOG_CMD_ID" \
            --instance-id "${{ env.EC2_INSTANCE_ID }}" \
            --region ${{ inputs.aws-region }} \
            --output text || true  

      - name: Verify Deployment
        run: |
          echo "Deployment completed."
          echo "Application is accessible at http://${{ env.EC2_PUBLIC_IP }}:${{ inputs.application-port }}/"
